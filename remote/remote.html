<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>DebugGUI</title>
		<style>
			body { margin: 0; background: grey; overflow: hidden; }
		</style>
	</head>
	<body>
        <input type="text" id="ip" value="localhost">
        <input type="text" id="port"><button id="button" onclick="launch()">LAUNCH</button>
		<script src="three.min.js"></script>
		<script src="dat.gui.min.js"></script>
		<script>
            const opcodes = {
                Control: 0,
                Mousepos: 1,
                Mouseclick: 2,
                Mousewheel: 3,
                Window: 4,
                Latency: 5,
                Keydown: 6,
                Keyup: 7,
                Charin: 8
            };

            const keys = {
                Tab: 0,
                ArrowLeft: 1,
                ArrowRight: 2,
                ArrowUp: 3,
                ArrowDown: 4,
                PageUp: 5,
                PageDown: 6,
                Home: 7,
                End: 8,
                Delete: 10,
                Backspace: 11,
                Enter: 13,
                Escape: 14
            };

            const altKeys = {
                a: 16,
                c: 17,
                v: 18,
                x: 19,
                y: 20,
                z: 21
            }

            function dataToStream(data) {
                this.buffer = new DataView(data);
                this.i = 0;
                this.getInt = () => { const d = this.buffer.getInt32(this.i, true); this.i+=4; return d };
                this.getFloat = () => { const d = this.buffer.getFloat32(this.i, true); this.i+=4; return d };
                this.getShort = () => { const d = this.buffer.getUint16(this.i, true); this.i+=2; return d };
                this.getChar = () => { const d = this.buffer.getInt8(this.i); this.i++; return d };

                this.setInt = (val) => { this.buffer.setInt32(this.i, val, true); this.i+=4 };
                this.setFloat = (val) => { this.buffer.setFloat32(this.i, val, true); this.i+=4 };
                this.setShort = (val) => { this.buffer.setInt16(this.i, val, true); this.i+=2 };
                this.setChar = (val) => { this.buffer.setInt8(this.i, val); this.i++ };

                return this;
            }

            function launch() {
                let input_port = document.getElementById("port");
                let input_ip = document.getElementById("ip");
                let button = document.getElementById("button");
                let port = input_port.value;
                let ip = input_ip.value;
                input_port.remove();
                input_ip.remove();
                button.remove();
                main(ip, port);
            }

            function main(ip, port) {
                new THREE.TextureLoader().load( "texture.png", ( map ) => {
                    let ws = new WebSocket("ws://" + ip + ":" + port, "dpl");
                    ws.binaryType = "arraybuffer";

                    const settings = {
                        interactive: false,
                        latency: 200,
                        fit: () => {
                            let buffer = new ArrayBuffer(9);
                            let stream = dataToStream(buffer);
                            stream.setChar(opcodes.Window);
                            stream.setInt(window.innerWidth);
                            stream.setInt(window.innerHeight);
                            ws.send(buffer);
                        },
                        input: "",
                    };

                    const gui = new dat.gui.GUI();
                    console.log(gui)

                    gui.add(settings, "interactive").onChange(() => {
                        if (settings.interactive) {
                            document.title = "DebugGUI [INTERACTIVE]";
                        } else {
                            document.title = "DebugGUI";
                        }
                    });

                    gui.add(settings, "fit");

                    gui.add(settings, "latency", 20, 1000).onChange(() => {
                        let buffer = new ArrayBuffer(5);
                        let stream = dataToStream(buffer);
                        stream.setChar(5);
                        stream.setInt(settings.latency);
                        ws.send(buffer);
                    });

                    gui.add(settings, "input").onChange(() => {
                        settings.input = "";
                        gui.__controllers[3].__input.value = "";
                    });

                    

                    let guniforms = {
                        tTex: { type: 't', value: null },
                    };

                    let ImVS = [
                        "attribute float alpha;",

                        "varying vec3 vColor;",
                        "varying vec2 vUv;",
                        "varying float vAlpha;",

                        "void main() {",
                            "vColor = color;",
                            "vUv = uv;",
                            "vAlpha = alpha;",
                            "gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);",
                        "}"].join("\n");

                    let ImFS = [
                        "varying vec3 vColor;",
                        "varying vec2 vUv;",
                        "varying float vAlpha;",
                        
                        "uniform sampler2D tTex;",

                        "void main() {",
                            "gl_FragColor = vec4( vColor, texture2D(tTex, vUv).a * vAlpha);",
                        "}" ].join("\n");

                    let material = new THREE.ShaderMaterial({
                        uniforms: guniforms,
                        vertexShader: ImVS,
                        fragmentShader: ImFS,
                        vertexColors: THREE.VertexColors,
                        transparent: true,
                        side: THREE.DoubleSide
                    });

                    const scene = new THREE.Scene();
                    let camera = new THREE.OrthographicCamera(0, window.innerWidth, 0, window.innerHeight, -1, 1);
                    camera.position.z = 1;

                    window.addEventListener('resize', resizeCallback, false);

                    function resizeCallback() {
                        camera = new THREE.OrthographicCamera(0, window.innerWidth, 0, window.innerHeight, -1, 1);
                        camera.position.z = 1;
                        renderer.setSize(window.innerWidth, window.innerHeight);
                    }

                    const MAX_VERTICES = 65535;

                    geometry = new THREE.BufferGeometry();
                    geometry.setIndex( new THREE.BufferAttribute( new Uint16Array ( MAX_VERTICES ), 1) );
                    geometry.setAttribute( 'position', new THREE.BufferAttribute( new Float32Array( MAX_VERTICES * 3 ), 3 ) );
                    geometry.setAttribute( 'uv',       new THREE.BufferAttribute( new Float32Array( MAX_VERTICES * 2 ), 2 ) );
                    geometry.setAttribute( 'color',    new THREE.BufferAttribute( new Float32Array( MAX_VERTICES * 3 ), 3 ) );
                    geometry.setAttribute( 'alpha',    new THREE.BufferAttribute( new Float32Array( MAX_VERTICES     ), 1 ) );
                    geometry.dynamic = true;
                    geometry.offsets = [{start: 0, index: 0, count: 0}];

                    const mesh = new THREE.Mesh(geometry, material);
                    mesh.frustumCulled = false;
                    scene.add(mesh);

                    const posArr = geometry.attributes.position.array;
                    const colorArr = geometry.attributes.color.array;
                    const alphaArr = geometry.attributes.alpha.array;
                    const uvArray = geometry.attributes.uv.array;
                    const indexArray = geometry.index.array;

                    function updateBuffers(data) {
                        let idx = 0;
                        let index_idx = 0;
                        let index_length = 0;
                        let vtx_length = 0;
                        let all_cmds = []
                        for (const cmd of data) {
                            all_cmds.push(...cmd.cmd);
                            for (let i = 0; i < cmd.vtx.length; ++i) {
                                const raw_color = cmd.vtx[i][2];
                                posArr[idx*3] = cmd.vtx[i][0];
                                posArr[idx*3+1] = cmd.vtx[i][1];
                                posArr[idx*3+2] = 0;
                                colorArr[idx*3] = (raw_color & 255)/255;
                                colorArr[idx*3+1] = (raw_color>>8 & 255)/255;
                                colorArr[idx*3+2] = (raw_color>>16 & 255)/255;
                                alphaArr[idx] = (raw_color>>24 & 255)/255;
                                uvArray[idx*2] = cmd.vtx[i][3];
                                uvArray[idx*2+1] = 1-cmd.vtx[i][4];
                                idx++;
                            }
                            for (let i = 0; i < cmd.idx.length; ++i) {
                                indexArray[index_idx] = cmd.idx[i] + vtx_length;
                                index_idx++;
                            }
                            index_length += cmd.idx.length;
                            vtx_length += cmd.vtx.length;
                        }
    
                        geometry.attributes.position.needsUpdate = true;
                        geometry.attributes.uv.needsUpdate = true;
                        geometry.attributes.color.needsUpdate = true;
                        geometry.attributes.alpha.needsUpdate = true;
                        geometry.index.needsUpdate = true;

                        return all_cmds;
                    }

                    function updateBuffersRaw(data) {
                        data = dataToStream(data);
                        let all_cmds = []
                        
                        let vtx_length = data.getInt();
                        let idx_length = data.getInt();
                        let cmd_length = data.getInt();

                        let idx = 0;
                        for (let i = 0; i < vtx_length; ++i) {
                            posArr[i*3] = data.getFloat();
                            posArr[i*3+1] = data.getFloat();
                            posArr[i*3+2] = 0;
                            uvArray[i*2] = data.getFloat();
                            uvArray[i*2+1] = 1-data.getFloat();
                            const raw_color = data.getInt();
                            colorArr[i*3] = (raw_color & 255)/255;
                            colorArr[i*3+1] = (raw_color>>8 & 255)/255;
                            colorArr[i*3+2] = (raw_color>>16 & 255)/255;
                            alphaArr[i] = (raw_color>>24 & 255)/255;
                        }
                        for (let i = 0; i < idx_length; ++i) {
                            indexArray[i] = data.getShort();
                        }

                        for (let i = 0; i < cmd_length; ++i) {
                            all_cmds.push({
                                cnt: data.getInt(),
                                clp: [data.getFloat(), data.getFloat(), data.getFloat(), data.getFloat()]
                            });
                        }

                        geometry.attributes.position.needsUpdate = true;
                        geometry.attributes.uv.needsUpdate = true;
                        geometry.attributes.color.needsUpdate = true;
                        geometry.attributes.alpha.needsUpdate = true;
                        geometry.index.needsUpdate = true;

                        return all_cmds;
                    }


                    map.needsUpdate = true;
                    map.minFilter = map.magFilter = THREE.NearestFilter;
                    guniforms.tTex.value = map;

                    const renderer = new THREE.WebGLRenderer();
                    renderer.autoClear = false;
                    renderer.setSize(window.innerWidth, window.innerHeight);
                    document.body.appendChild(renderer.domElement);
                    renderer.setScissorTest(true);

                    ws.onmessage = e => {
                        const all_cmds = updateBuffersRaw(e.data);
                        let curr_base = 0;
                        renderer.clear();
                        for (const cmd of all_cmds) {
                            renderer.setScissor(cmd.clp[0], window.innerHeight - cmd.clp[3], cmd.clp[2] - cmd.clp[0], cmd.clp[3] - cmd.clp[1]);
                            geometry.setDrawRange(curr_base, cmd.cnt);
                            renderer.render(scene, camera);
                            curr_base += cmd.cnt;
                        }
                    }

                    renderer.domElement.onmousemove = e => {
                        if (!settings.interactive) return;
                        let buffer = new ArrayBuffer(9);
                        let stream = dataToStream(buffer);
                        stream.setChar(opcodes.Mousepos);
                        stream.setFloat(e.offsetX);
                        stream.setFloat(e.offsetY);
                        ws.send(buffer);
                    }

                    renderer.domElement.onmousedown = e => {
                        if (!settings.interactive) return;
                        let buffer = new ArrayBuffer(2);
                        let stream = dataToStream(buffer);
                        stream.setChar(opcodes.Mouseclick);
                        stream.setChar(1);
                        ws.send(buffer);
                    }

                    renderer.domElement.onmouseup = e => {
                        if (!settings.interactive) return;
                        let buffer = new ArrayBuffer(2);
                        let stream = dataToStream(buffer);
                        stream.setChar(opcodes.Mouseclick);
                        stream.setChar(0);
                        ws.send(buffer);
                    }

                    renderer.domElement.onwheel = e => {
                        if (!settings.interactive) return;
                        let buffer = new ArrayBuffer(2);
                        let stream = dataToStream(buffer);
                        stream.setChar(opcodes.Mousewheel);
                        stream.setChar(e.wheelDelta > 0 ? 1 : -1);
                        ws.send(buffer);
                    }

                    document.onkeydown = e => {
                        if (!settings.interactive) return;
                        let buffer = new ArrayBuffer(2);
                        let stream = dataToStream(buffer);
                        stream.setChar(opcodes.Keydown);
                        if (keys[e.key] !== undefined) {
                            stream.setChar(keys[e.key]);
                            ws.send(buffer);
                        } else if (e.ctrlKey && altKeys[e.key] != undefined) {
                            stream.setChar(altKeys[e.key]);
                            ws.send(buffer);
                        }
                    }

                    document.onkeyup = e => {
                        if (!settings.interactive) return;
                        let buffer = new ArrayBuffer(2);
                        let stream = dataToStream(buffer);
                        stream.setChar(opcodes.Keyup);
                        if (keys[e.key] !== undefined) {
                            stream.setChar(keys[e.key]);
                            ws.send(buffer);
                        } else if (e.ctrlKey && altKeys[e.key] != undefined) {
                            stream.setChar(altKeys[e.key]);
                            ws.send(buffer);
                        }
                    }

                    document.onkeypress = e => {
                        if (!settings.interactive) return;
                        if (e.key.length === 1) {
                            let buffer = new ArrayBuffer(2);
                            let stream = dataToStream(buffer);
                            stream.setChar(opcodes.Charin);
                            stream.setChar(e.key.charCodeAt(0));
                            ws.send(buffer);
                        }
                    }

                    renderer.domElement.ontouchmove = e => {
                        if (!settings.interactive) return;
                        e.preventDefault();
                        let buffer = new ArrayBuffer(9);
                        let stream = dataToStream(buffer);
                        stream.setChar(opcodes.Mousepos);
                        stream.setFloat(e.touches[0].clientX);
                        stream.setFloat(e.touches[0].clientY);
                        ws.send(buffer);
                    }

                    renderer.domElement.ontouchstart = e => {
                        if (!settings.interactive) return;
                        renderer.domElement.ontouchmove(e);
                        let buffer = new ArrayBuffer(2);
                        let stream = dataToStream(buffer);
                        stream.setChar(opcodes.Mouseclick);
                        stream.setChar(1);
                        ws.send(buffer);
                    }

                    renderer.domElement.ontouchend = e => {
                        if (!settings.interactive) return;
                        let buffer = new ArrayBuffer(2);
                        let stream = dataToStream(buffer);
                        stream.setChar(opcodes.Mouseclick);
                        stream.setChar(0);
                        ws.send(buffer);
                    }
                });
            }
		</script>
	</body>
</html>
