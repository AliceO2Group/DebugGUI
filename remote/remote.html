<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>DebugGUI</title>
		<style>
			body { margin: 0; background: grey; overflow: hidden; }
		</style>
	</head>
	<body>
        <input type="text" id="ip" value="localhost">
        <input type="text" id="port"><button id="button" onclick="launch()">LAUNCH</button>
		<script src="dat.gui.min.js"></script>
		<script>
            const opcodes = {
                Control: 0,
                Mousepos: 1,
                Mouseclick: 2,
                Mousewheel: 3,
                Window: 4,
                Latency: 5,
                Keydown: 6,
                Keyup: 7,
                Charin: 8
            };

            const keys = {
                Tab: 0,
                ArrowLeft: 1,
                ArrowRight: 2,
                ArrowUp: 3,
                ArrowDown: 4,
                PageUp: 5,
                PageDown: 6,
                Home: 7,
                End: 8,
                Delete: 10,
                Backspace: 11,
                Enter: 13,
                Escape: 14
            };

            const altKeys = {
                a: 16,
                c: 17,
                v: 18,
                x: 19,
                y: 20,
                z: 21
            }

            function dataToStream(data) {
                this.buffer = new DataView(data);
                this.i = 0;
                this.getInt = () => { const d = this.buffer.getInt32(this.i, true); this.i+=4; return d };
                this.getFloat = () => { const d = this.buffer.getFloat32(this.i, true); this.i+=4; return d };
                this.getShort = () => { const d = this.buffer.getUint16(this.i, true); this.i+=2; return d };
                this.getChar = () => { const d = this.buffer.getInt8(this.i); this.i++; return d };

                this.setInt = (val) => { this.buffer.setInt32(this.i, val, true); this.i+=4 };
                this.setFloat = (val) => { this.buffer.setFloat32(this.i, val, true); this.i+=4 };
                this.setShort = (val) => { this.buffer.setInt16(this.i, val, true); this.i+=2 };
                this.setChar = (val) => { this.buffer.setInt8(this.i, val); this.i++ };

                return this;
            }

            function launch() {
                let input_port = document.getElementById("port");
                let input_ip = document.getElementById("ip");
                let button = document.getElementById("button");
                let port = input_port.value;
                let ip = input_ip.value;
                input_port.remove();
                input_ip.remove();
                button.remove();
                document.body.style.background = "black";
                main(ip, port);
            }

            function main(ip, port) {
                const image = new Image();
                image.src = "texture.png";
                image.onload = () => {
                    let ws = new WebSocket("ws://" + ip + ":" + port, "dpl");
                    ws.binaryType = "arraybuffer";

                    const settings = {
                        interactive: false,
                        latency: 200,
                        fit: () => {
                            let buffer = new ArrayBuffer(9);
                            let stream = dataToStream(buffer);
                            stream.setChar(opcodes.Window);
                            stream.setInt(window.innerWidth);
                            stream.setInt(window.innerHeight);
                            ws.send(buffer);
                        },
                        input: "",
                    };

                    const gui = new dat.gui.GUI();

                    gui.add(settings, "interactive").onChange(() => {
                        if (settings.interactive) {
                            document.title = "DebugGUI [INTERACTIVE]";
                        } else {
                            document.title = "DebugGUI";
                        }
                    });

                    gui.add(settings, "fit");

                    gui.add(settings, "latency", 20, 1000).onChange(() => {
                        let buffer = new ArrayBuffer(5);
                        let stream = dataToStream(buffer);
                        stream.setChar(5);
                        stream.setInt(settings.latency);
                        ws.send(buffer);
                    });

                    gui.add(settings, "input").onChange(() => {
                        settings.input = "";
                        gui.__controllers[3].__input.value = "";
                    });

                    

                    let guniforms = {
                        tTex: { type: 't', value: null },
                    };

                    let vsSrc = `
                        attribute vec2 aPosition;
                        attribute vec4 aColor;
                        attribute mediump vec2 aUv;

                        varying vec4 vColor;
                        varying vec2 vUv;

                        uniform mat4 uProjectionMatrix;

                        void main() {
                            vColor = aColor;
                            vUv = aUv;
                            gl_Position = uProjectionMatrix * vec4(aPosition, 0.0, 1.0);
                        }`;

                    let fsSrc = `
                        varying mediump vec4 vColor;
                        varying mediump vec2 vUv;

                        uniform sampler2D tTex;
                        
                        void main() {
                            gl_FragColor = vec4(vColor.rgb, vColor.a * texture2D(tTex, vUv).a);
                        }`;

                    
                    const canvas = document.createElement("canvas");
                    canvas.height = window.innerHeight;
                    canvas.width = window.innerWidth;
                    document.body.appendChild(canvas);

                    const gl = canvas.getContext("webgl");
                    gl.enable(gl.SCISSOR_TEST);
                    gl.enable(gl.BLEND);
                    gl.blendEquation(gl.FUNC_ADD);
                    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
                    gl.disable(gl.CULL_FACE);
                    gl.disable(gl.DEPTH_TEST);

                    const vs = gl.createShader(gl.VERTEX_SHADER);
                    gl.shaderSource(vs, vsSrc);
                    gl.compileShader(vs);

                    const fs = gl.createShader(gl.FRAGMENT_SHADER);
                    gl.shaderSource(fs, fsSrc);
                    gl.compileShader(fs);

                    const shaderProgram = gl.createProgram();
                    gl.attachShader(shaderProgram, vs);
                    gl.attachShader(shaderProgram, fs);
                    gl.linkProgram(shaderProgram);

                    const texture = gl.createTexture();
                    gl.bindTexture(gl.TEXTURE_2D, texture);
                    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
                    gl.generateMipmap(gl.TEXTURE_2D);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);

                    const MAX_VERTICES = 65535;

                    const posArr = new Float32Array( MAX_VERTICES * 2 );
                    const colorArr = new Float32Array( MAX_VERTICES * 4 );
                    const uvArray = new Float32Array( MAX_VERTICES * 2 );
                    const indexArray = new Uint16Array ( MAX_VERTICES );

                    const positionBuffer = gl.createBuffer();
                    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
                    gl.bufferData(gl.ARRAY_BUFFER, posArr, gl.DYNAMIC_DRAW);

                    const colorBuffer = gl.createBuffer();
                    gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
                    gl.bufferData(gl.ARRAY_BUFFER, colorArr, gl.DYNAMIC_DRAW);

                    const uvBuffer = gl.createBuffer();
                    gl.bindBuffer(gl.ARRAY_BUFFER, uvBuffer);
                    gl.bufferData(gl.ARRAY_BUFFER, uvArray, gl.DYNAMIC_DRAW);

                    const indexBuffer = gl.createBuffer();
                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
                    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indexArray, gl.DYNAMIC_DRAW);

                    const projMatrix = new Float32Array([
                        2.0 / window.innerWidth, 0.0, 0.0, 0.0,
                        0.0, 2.0 / -window.innerHeight, 0.0, 0.0,
                        0.0, 0.0, -1.0, 0.0,
                        -1.0, 1.0, 0.0, 1.0,
                    ]);

                    window.addEventListener('resize', resizeCallback, false);

                    function resizeCallback() {
                        projMatrix[0] = 2.0 / window.innerWidth;
                        projMatrix[5] = 2.0 / -window.innerHeight;
                        gl.uniformMatrix4fv(
                            gl.getUniformLocation(shaderProgram, "uProjectionMatrix"),
                            false,
                            projMatrix
                        );
                        canvas.width = window.innerWidth;
                        canvas.height = window.innerHeight;
                        gl.viewport(0, 0, window.innerWidth, window.innerHeight);
                    }


                    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
                    gl.vertexAttribPointer(
                        gl.getAttribLocation(shaderProgram, "aPosition"),
                        2,
                        gl.FLOAT,
                        false,
                        0,
                        0
                    );

                    gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
                    gl.vertexAttribPointer(
                        gl.getAttribLocation(shaderProgram, "aColor"),
                        4,
                        gl.FLOAT,
                        false,
                        0,
                        0
                    );

                    gl.bindBuffer(gl.ARRAY_BUFFER, uvBuffer);
                    gl.vertexAttribPointer(
                        gl.getAttribLocation(shaderProgram, "aUv"),
                        2,
                        gl.FLOAT,
                        false,
                        0,
                        0
                    );
                        
                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);

                    gl.enableVertexAttribArray(gl.getAttribLocation(shaderProgram, "aPosition"));
                    gl.enableVertexAttribArray(gl.getAttribLocation(shaderProgram, "aColor"));
                    gl.enableVertexAttribArray(gl.getAttribLocation(shaderProgram, "aUv"));
                    
                    gl.useProgram(shaderProgram);

                    gl.activeTexture(gl.TEXTURE0);
                    gl.bindTexture(gl.TEXTURE_2D, texture);
                    gl.uniform1i(gl.getUniformLocation(shaderProgram, "tTex"), 0);


                    gl.uniformMatrix4fv(
                        gl.getUniformLocation(shaderProgram, "uProjectionMatrix"),
                        false,
                        projMatrix
                    );

                    function updateBuffersRaw(data) {
                        data = dataToStream(data);
                        let all_cmds = []
                        
                        let vtx_length = data.getInt();
                        let idx_length = data.getInt();
                        let cmd_length = data.getInt();

                        let idx = 0;
                        for (let i = 0; i < vtx_length; ++i) {
                            posArr[i*2] = data.getFloat();
                            posArr[i*2+1] = data.getFloat();
                            uvArray[i*2] = data.getFloat();
                            uvArray[i*2+1] = data.getFloat();
                            const raw_color = data.getInt();
                            colorArr[i*4] = (raw_color & 255)/255;
                            colorArr[i*4+1] = (raw_color>>8 & 255)/255;
                            colorArr[i*4+2] = (raw_color>>16 & 255)/255;
                            colorArr[i*4+3] = (raw_color>>24 & 255)/255;
                        }
                        for (let i = 0; i < idx_length; ++i) {
                            indexArray[i] = data.getShort();
                        }

                        for (let i = 0; i < cmd_length; ++i) {
                            all_cmds.push({
                                cnt: data.getInt(),
                                clp: [data.getFloat(), data.getFloat(), data.getFloat(), data.getFloat()]
                            });
                        }

                        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
                        gl.bufferSubData(gl.ARRAY_BUFFER, 0, posArr);
    
                        gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
                        gl.bufferSubData(gl.ARRAY_BUFFER, 0, colorArr);
    
                        gl.bindBuffer(gl.ARRAY_BUFFER, uvBuffer);
                        gl.bufferSubData(gl.ARRAY_BUFFER, 0, uvArray);
    
                        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
                        gl.bufferSubData(gl.ELEMENT_ARRAY_BUFFER, 0, indexArray);

                        return all_cmds;
                    }


                    ws.onmessage = e => {
                        const all_cmds = updateBuffersRaw(e.data);


                        let curr_base = 0;
                        for (const cmd of all_cmds) {
                            gl.scissor(cmd.clp[0], window.innerHeight - cmd.clp[3], cmd.clp[2] - cmd.clp[0], cmd.clp[3] - cmd.clp[1]);
                            gl.drawElements(gl.TRIANGLES, cmd.cnt, gl.UNSIGNED_SHORT, curr_base*2);
                            curr_base += cmd.cnt;
                        }
                    }

                    canvas.onmousemove = e => {
                        if (!settings.interactive) return;
                        let buffer = new ArrayBuffer(9);
                        let stream = dataToStream(buffer);
                        stream.setChar(opcodes.Mousepos);
                        stream.setFloat(e.offsetX);
                        stream.setFloat(e.offsetY);
                        ws.send(buffer);
                    }

                    canvas.onmousedown = e => {
                        if (!settings.interactive) return;
                        let buffer = new ArrayBuffer(2);
                        let stream = dataToStream(buffer);
                        stream.setChar(opcodes.Mouseclick);
                        stream.setChar(1);
                        ws.send(buffer);
                    }

                    canvas.onmouseup = e => {
                        if (!settings.interactive) return;
                        let buffer = new ArrayBuffer(2);
                        let stream = dataToStream(buffer);
                        stream.setChar(opcodes.Mouseclick);
                        stream.setChar(0);
                        ws.send(buffer);
                    }

                    canvas.onwheel = e => {
                        if (!settings.interactive) return;
                        let buffer = new ArrayBuffer(2);
                        let stream = dataToStream(buffer);
                        stream.setChar(opcodes.Mousewheel);
                        stream.setChar(e.wheelDelta > 0 ? 1 : -1);
                        ws.send(buffer);
                    }

                    document.onkeydown = e => {
                        if (!settings.interactive) return;
                        let buffer = new ArrayBuffer(2);
                        let stream = dataToStream(buffer);
                        stream.setChar(opcodes.Keydown);
                        if (keys[e.key] !== undefined) {
                            stream.setChar(keys[e.key]);
                            ws.send(buffer);
                        } else if (e.ctrlKey && altKeys[e.key] != undefined) {
                            stream.setChar(altKeys[e.key]);
                            ws.send(buffer);
                        }
                    }

                    document.onkeyup = e => {
                        if (!settings.interactive) return;
                        let buffer = new ArrayBuffer(2);
                        let stream = dataToStream(buffer);
                        stream.setChar(opcodes.Keyup);
                        if (keys[e.key] !== undefined) {
                            stream.setChar(keys[e.key]);
                            ws.send(buffer);
                        } else if (e.ctrlKey && altKeys[e.key] != undefined) {
                            stream.setChar(altKeys[e.key]);
                            ws.send(buffer);
                        }
                    }

                    document.onkeypress = e => {
                        if (!settings.interactive) return;
                        if (e.key.length === 1) {
                            let buffer = new ArrayBuffer(2);
                            let stream = dataToStream(buffer);
                            stream.setChar(opcodes.Charin);
                            stream.setChar(e.key.charCodeAt(0));
                            ws.send(buffer);
                        }
                    }

                    canvas.ontouchmove = e => {
                        if (!settings.interactive) return;
                        e.preventDefault();
                        let buffer = new ArrayBuffer(9);
                        let stream = dataToStream(buffer);
                        stream.setChar(opcodes.Mousepos);
                        stream.setFloat(e.touches[0].clientX);
                        stream.setFloat(e.touches[0].clientY);
                        ws.send(buffer);
                    }

                    canvas.ontouchstart = e => {
                        if (!settings.interactive) return;
                        canvas.ontouchmove(e);
                        let buffer = new ArrayBuffer(2);
                        let stream = dataToStream(buffer);
                        stream.setChar(opcodes.Mouseclick);
                        stream.setChar(1);
                        ws.send(buffer);
                    }

                    canvas.ontouchend = e => {
                        if (!settings.interactive) return;
                        let buffer = new ArrayBuffer(2);
                        let stream = dataToStream(buffer);
                        stream.setChar(opcodes.Mouseclick);
                        stream.setChar(0);
                        ws.send(buffer);
                    }
                };
            }
		</script>
	</body>
</html>
